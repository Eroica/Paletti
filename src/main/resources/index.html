<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <link rel="stylesheet" href="style.css">
</head>

<body>

<div class="imagePreview empty"></div>

<ul id="ColorPalette" class="colorPalette"></ul>

<template id="ColorTile">
    <li class="colorPalette__color">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="21" viewBox="0 0 16 21">
            <path fill="#000" fill-rule="evenodd" d="M3,1 C3,2.1045695 3.8954305,3 5,3 L11,3 C12.1045695,3 13,2.1045695 13,1 L15,1 C15.5522847,1 16,1.44771525 16,2 L16,20 C16,20.5522847 15.5522847,21 15,21 L1,21 C0.44771525,21 6.76353751e-17,20.5522847 0,20 L0,2 C-6.76353751e-17,1.44771525 0.44771525,1 1,1 L3,1 Z M1,4 L15,4 L15,20 L1,20 L1,4 Z M5,0 L11,0 C11.5522847,-1.01453063e-16 12,0.44771525 12,1 L12,1 C12,1.55228475 11.5522847,2 11,2 L5,2 C4.44771525,2 4,1.55228475 4,1 L4,1 L4,1 C4,0.44771525 4.44771525,1.01453063e-16 5,0 Z"/>
        </svg>
    </li>
</template>

<script src="color-thief.umd.js"></script>
<script>
    "use strict";

    let colorPalette;

    function toHex (rgb) {
        return "#" + ("0" + parseInt(rgb[0], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2);
    }

    function lerp (value, fromLow, fromHigh, toLow, toHigh) {
        return toLow + (((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow))
    }

    function toSecondaryColor (originalRgb) {
        const rgb = [originalRgb[0], originalRgb[1], originalRgb[2]];
        const brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        const difference = (brightness < 128) ? lerp(brightness, 10, 128, 160, 100) : lerp(brightness, 128, 246, -100, -160);

        for (let i = 0; i < rgb.length; i++) {
            rgb[i] += difference;
            rgb[i] = rgb[i] < 0 ? 0 : rgb[i] > 255 ? 255 : rgb[i] | 0;
        }

        return rgb;
    }

    function update (base64) {
        const img = document.createElement("img");
        img.src = "data:image/png;base64," + base64;
        img.className = "hiddenImage";

        document.querySelector(".imagePreview").style.backgroundImage = "url(data:image/png;base64," + base64 + ")";
        document.querySelector(".imagePreview").classList.remove("empty");

        img.addEventListener("load", function (e) {
            colorPalette.getColorsFrom(img);
            colorPalette.update();
            document.body.removeChild(img);
        });

        document.body.appendChild(img);
    }

    function ColorPalette (initialSize) {
        const MAX_COLORS = 12;
        const MIN_COLORS = 6;
        let colorCount = initialSize || MIN_COLORS;
        let currentPalette = null;

        const colorThief = new ColorThief();
        const COLOR_TILE = document.getElementById("ColorTile");
        const COLOR_LIST = document.getElementById("ColorPalette");

        this.addTile = function () {
            if (colorCount >= MAX_COLORS) {
                colorCount = MAX_COLORS;
                return;
            }
            colorCount++;
            const newTile = COLOR_TILE.content.cloneNode(true);
            COLOR_LIST.append(newTile);
            this.update();
        };

        this.removeTile = function () {
            if (colorCount <= MIN_COLORS) {
                colorCount = MIN_COLORS;
                return;
            }
            colorCount--;
            COLOR_LIST.children[COLOR_LIST.children.length - 1].remove();
            this.update();
        };

        this.getColorsFrom = function (img) {
            currentPalette = colorThief.getPalette(img, MAX_COLORS);
        };

        this.update = function () {
            if (currentPalette === null) {
                return;
            }
            currentPalette.slice(0, colorCount).forEach(function (color, i) {
                const li = document.querySelector(".colorPalette__color:nth-of-type(" + (i + 1) + ")");
                li.style.backgroundColor = toHex(color);
                li.setAttribute("data-color", toHex(color));
                const secondaryColor = toSecondaryColor(color);
                li.querySelector("svg path").setAttribute("fill", toHex(secondaryColor));
            });
        };

        for (let i=0; i < colorCount; i++) {
            const newTile = COLOR_TILE.content.cloneNode(true);
            COLOR_LIST.append(newTile)
        }
    }

    colorPalette = new ColorPalette();

    document.addEventListener("wheel", function (event) {
        if (event.deltaY < 0) {
            colorPalette.addTile();
        } else {
            colorPalette.removeTile();
        }
    });

    document.addEventListener("keydown", function (event) {
       if (event.keyCode === 38) {
           colorPalette.addTile();
       }
       if (event.keyCode === 40) {
           colorPalette.removeTile();
       }
    });

    const COLOR_LIST = document.getElementById("ColorPalette");
    COLOR_LIST.addEventListener("click", function (event) {
        const target = event.target.closest("li");
        const color = target.getAttribute("data-color");
        // ClipboardManager in Controller.kt
        window.ClipboardManager.putIntoClipboard(color);
    });
</script>
</body>
</html>
